# PreWorkout out
# simple block
# simple map
# GPL vs DSL (internal/external)
# is block function or object oriented feature?
#

# Proc#to_proc
:one.to_proc, 1.to_proc, "one".to_proc, "1".to_proc 
# Part of the protocol for converting objects to Proc objects.
# Instances of class Proc simply return themselves.
[1,2,3].map(&Hello.to_proc.to_proc.to_proc)

class Hello
  def self.to_proc
    Proc.new { |item| "Home Chef #{item}" }
  end
end
# [1,2,3].map(&Hello) => ["Home Chef 1", "Home Chef 2", "Home Chef 3"]

# 1
ages = [3, 5, 26, 33, 55, 34, 94, 12]

puts ages.select { |age| age > 40 }

# 2 Creating a proc - a "block" OBJECT
old = Proc.new { |age| age > 40 }

# 3 Converting proc back into block

puts ages.select(&old)

# Calling the proc later - deferred evaluation

puts old.call(90) # true
puts old.call(21) # false

# Compare? yield vs block

def your_age(age)
  yield
  puts age
end

def my_age(age, &block_as_proc)
  block_as_proc.call
  puts age
end

your_age(37) { print "Your age is..." }
my_age(36) { print "My age is..." }

# &block_as_proc is actually evoking `block_as_proc.to_proc`
# Hello.to_proc => returns an instance of a `Proc` obviously

class Hello
  def self.to_proc
    Proc.new { puts "hello" }
  end
end

# my_age(63, &Hello) # => "Hello", 63

# Symbol#to_proc "ampersand colon" or "pretzel colon" http://blog.honeybadger.io/how-ruby-ampersand-colon-works/

# `&` calls `to_proc` on its operand and passes it in as a block

class Symbol
  def to_proc
    Proc.new do |item|
      byebug
      item.send self
    end
  end
end

# Enumberable methods like `each` and `map` accept a block.
# For each item they call the block and pass it a reference to the item.
# The block in this case is generated by calling `to_proc` on the symbol.

# &:name evaluates to a Proc, which does item.send(:name)
items.map(&:name)

# 
# Buildling Our Own Testing Framerwork DSL vs GPL...

it "the sky is falling" do
  @sky_height < 300
end

it "it's getting closer" do
  @sky_height < @mountains_height
end

before do
  puts "Setting up sky"
  @sky_height = 100
end

before do
  puts "Setting up mountains"
  @mountains_height = 200
end

# Setting up sky
# Setting up mountains
# ALERT: the sky is falling
# Setting up sky
# Setting up mountains
# ALERT: it's getting closer

# via yield
def it(message)
  puts message
  yield
end

# via block
def it(message, &expectation)
  puts message
  expectation.call
end

# How to wire this all up round 1
# RSPEC
# https://github.com/rspec/rspec-core/blob/master/lib/rspec/core/hooks.rb
# #before: https://github.com/rspec/rspec-core/blob/master/lib/rspec/core/hooks.rb#L197-L199
# #run: https://github.com/rspec/rspec-core/blob/master/lib/rspec/core/hooks.rb#L347-L349

def run(example)
  example.instance_exec(example, &block)
end

# Dry Run
# https://github.com/rspec/rspec-core/blob/master/lib/rspec/core/hooks.rb#L451-L467


# https://github.com/rspec/rspec-core/blob/master/lib/rspec/core/example.rb#L446-L448
def instance_exec(*args, &block)
  @example_group_instance.instance_exec(*args, &block)
end

it 'removes markdown' do
  meal = FactoryGirl.build(:recipe, :description => "This is a **bold** and _italic_ statement")
  expect(meal.description_no_markdown).to eq("This is a bold and italic statement")
end

# @example_group_instance => #<RSpec::ExampleGroups::Recipe::DescriptionNoMarkdown "removes markdown" (./spec/models/recipe_spec.rb:24)> # actually spec
# args => [#<RSpec::Core::Example "removes markdown">]
# block => #<Proc:0x007fb8bff3bb80@/Users/mike/Github/mealhand/spec/models/recipe_spec.rb:18> # before block

@its = {}
@before = []

def it(name, &block)
  # convert blocks to `Proc`s and stores them in a hash :-) #########
  # has is a top-level instance variable so it is visible

  # name is the "text we right" of the method
  @its[name] = block # still a proc...I haven't called `call()`
end

# def setup(when = :each, &block)
def before(&block)
  @before << block
end

# Clean rooms pattern

# #instance_eval
# #instance_evoke
